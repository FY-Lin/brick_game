<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ‰“ç£šå¡Š</title>
    <style>
        body { margin: 0; background: #1a1a1a; color: white; font-family: sans-serif; overflow: hidden; touch-action: none; }
        canvas { display: block; background: #000; margin: 0 auto; border-bottom: 5px solid #333; }
        #ui { position: absolute; top: 15px; left: 15px; pointer-events: none; font-size: 18px; text-shadow: 1px 1px 2px #000; z-index: 10; }
        #msg { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 32px; font-weight: bold; display: none; text-align: center; z-index: 20; }
        .btn { padding: 15px 40px; font-size: 20px; background: #3498db; color: white; border: none; border-radius: 30px; cursor: pointer; position: absolute; top: 55%; left: 50%; transform: translate(-50%, -50%); display: none; box-shadow: 0 4px #2980b9; z-index: 21; }
        #hint { position: absolute; bottom: 30px; width: 100%; text-align: center; color: #aaa; font-size: 14px; pointer-events: none; transition: opacity 0.5s; }
    </style>
</head>
<body>
    <div id="ui">â¤ï¸ çƒæ•¸: <span id="lives">5</span> | ğŸ§± å‰©é¤˜: <span id="bricks">0</span></div>
    <div id="msg">éŠæˆ²çµæŸ</div>
    <button id="restartBtn" class="btn" onclick="resetFullGame()">å†ç©ä¸€å±€</button>
    <div id="hint">æŒ‰ä½ç™¼å°„è‡ºå·¦å³ç§»å‹•ï¼Œä¸‹æ–¹æ»‘å‹•ç„æº–ï¼Œæ”¾é–‹å°„æ“Š</div>
    
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const liveDisp = document.getElementById('lives');
const brickDisp = document.getElementById('bricks');
const restartBtn = document.getElementById('restartBtn');
const msgDisp = document.getElementById('msg');
const hintDisp = document.getElementById('hint');

let canvasW = window.innerWidth;
let canvasH = window.innerHeight;
canvas.width = canvasW;
canvas.height = canvasH;

const PADDLE_BOTTOM_OFFSET = 120; // æª¯é¢è·é›¢åº•éƒ¨çš„é«˜åº¦

let lives = 5, ballActive = false;
let paddleW = canvasW / 4, paddleH = 18;
let paddleX = (canvasW - paddleW) / 2;
let ballX, ballY, ballDX, ballDY, ballR = 8, ballPower = 1;
let launchAngle = -Math.PI / 2;
let bricks = [], items = [];

let isDragging = false;
let isAiming = false;

function initBricks() {
    bricks = [];
    let greenCount = 0, redCount = 0;
    const rowCount = 6, colCount = 6;
    const padding = 8;
    const bW = (canvasW - (padding * (colCount + 1))) / colCount;
    const bH = 25;

    for(let r=0; r<rowCount; r++) {
        bricks[r] = [];
        for(let c=0; c<colCount; c++) {
            let type = 'normal', hp = 1;
            let rand = Math.random();
            if(rand > 0.85) { type = 'gold'; hp = 3; }
            else if(rand > 0.7) { 
                if (redCount < greenCount) { type = 'item_neg'; redCount++; } 
                else { type = 'item_pos'; greenCount++; }
            } else if(rand > 0.55) { type = 'item_pos'; greenCount++; }
            bricks[r][c] = { x: c*(bW+padding)+padding, y: r*(bH+padding)+80, status: hp, type: type, w: bW, h: bH };
        }
    }
}

function spawnItem(x, y, type) {
    const posEffects = [{label: 'â¬†ï¸', effect: 'wider'}, {label: 'â•', effect: 'life'}, {label: 'ğŸ”¥', effect: 'power'}];
    const negEffects = [{label: 'â¬‡ï¸', effect: 'narrow'}, {label: 'ğŸ’€', effect: 'weaker'}];
    let e = (type === 'item_pos' ? posEffects : negEffects)[Math.floor(Math.random() * (type === 'item_pos' ? 3 : 2))];
    items.push({ ...e, x: x + 20, y: y, color: type === 'item_pos' ? '#2ecc71' : '#e74c3c' });
}

function draw() {
    ctx.clearRect(0, 0, canvasW, canvasH);
    
    // ç¹ªè£½æª¯é¢
    const paddleY = canvasH - PADDLE_BOTTOM_OFFSET;
    ctx.fillStyle = "#3498db";
    ctx.fillRect(paddleX, paddleY, paddleW, paddleH);

    // ç¹ªè£½å°å¼•ç·š (åƒ…æœªç™¼å°„æ™‚)
    if (!ballActive && isDragging) drawGuideline();

    // ç£šå¡Šèˆ‡ UI æ›´æ–°
    let remaining = 0;
    bricks.flat().forEach(b => {
        if(b.status > 0) {
            remaining++;
            ctx.fillStyle = b.type === 'gold' ? `rgba(255,215,0,${b.status/3})` : (b.type === 'item_pos' ? "#2ecc71" : (b.type === 'item_neg' ? "#e74c3c" : "#555"));
            ctx.fillRect(b.x, b.y, b.w, b.h);
        }
    });
    brickDisp.innerText = remaining;

    // é“å…·é‚è¼¯
    items.forEach((it, i) => {
        it.y += 2.5;
        ctx.fillStyle = it.color; ctx.font = "24px Arial"; ctx.fillText(it.label, it.x, it.y);
        if(it.y > paddleY && it.y < paddleY + paddleH && it.x > paddleX && it.x < paddleX + paddleW) {
            if(it.effect === 'wider') paddleW += 40;
            if(it.effect === 'narrow') paddleW = Math.max(40, paddleW - 40);
            if(it.effect === 'life') { lives++; liveDisp.innerText = lives; }
            if(it.effect === 'power') ballPower = 3;
            if(it.effect === 'weaker') ballPower = 0.5;
            items.splice(i, 1);
        } else if(it.y > canvasH) items.splice(i, 1);
    });

    // çƒçš„ç‰©ç†
    if(ballActive) {
        // ç‰†å£ç¢°æ’
        if(ballX + ballDX > canvasW - ballR || ballX + ballDX < ballR) ballDX = -ballDX;
        if(ballY + ballDY < ballR) ballDY = -ballDY;

        // æ ¸å¿ƒä¿®å¾©ï¼šç²¾æº–æª¯é¢ç¢°æ’
        // åªæœ‰çƒåœ¨æª¯é¢é«˜åº¦ä¸Šæ–¹ï¼Œä¸”çƒæ­£åœ¨å‘ä¸‹æ‰ (ballDY > 0) æ™‚æ‰åˆ¤å®š
        if (ballY + ballR >= paddleY && ballY + ballR <= paddleY + paddleH && ballDY > 0) {
            if (ballX > paddleX && ballX < paddleX + paddleW) {
                ballY = paddleY - ballR; // å¼·åˆ¶çƒå›åˆ°æª¯é¢ä¸Šæ–¹ï¼Œé˜²æ­¢å¡ä½
                ballDY = -Math.abs(ballDY);
                ballDX = (ballX - (paddleX + paddleW/2)) / (paddleW/2) * 5;
            }
        }

        // æ‰è½åˆ¤å®š
        if (ballY - ballR > canvasH) {
            lives--; liveDisp.innerText = lives;
            if(lives <= 0) endGame("GAME OVER"); else resetBall();
        }

        // ç£šå¡Šç¢°æ’
        bricks.flat().forEach(b => {
            if(b.status > 0 && ballX > b.x && ballX < b.x+b.w && ballY > b.y && ballY < b.y+b.h) {
                ballDY = -ballDY; b.status -= ballPower;
                if(b.status <= 0 && b.type.startsWith('item')) spawnItem(b.x, b.y, b.type);
            }
        });
        ballX += ballDX; ballY += ballDY;
    } else {
        ballX = paddleX + paddleW / 2;
        ballY = paddleY - ballR - 2;
    }

    // çƒé«”ç¹ªè£½
    ctx.beginPath(); ctx.arc(ballX, ballY, ballR, 0, Math.PI*2);
    ctx.fillStyle = (ballPower > 1) ? "#f1c40f" : "#fff";
    if(ballPower > 1) { ctx.shadowBlur = 15; ctx.shadowColor = "#f1c40f"; }
    ctx.fill(); ctx.shadowBlur = 0;

    if(remaining === 0 && bricks.length > 0) endGame("YOU WIN!");
    requestAnimationFrame(draw);
}

function drawGuideline() {
    ctx.save(); ctx.beginPath(); ctx.setLineDash([6, 4]);
    ctx.strokeStyle = isAiming ? "#2ecc71" : "rgba(255, 255, 255, 0.2)";
    let curX = ballX, curY = ballY, curDX = Math.cos(launchAngle), curDY = Math.sin(launchAngle);
    let reflections = 0; ctx.moveTo(curX, curY);
    for (let i = 0; i < 500; i++) {
        let nextX = curX + curDX * 4; let nextY = curY + curDY * 4;
        let collided = false;
        if (nextX < ballR || nextX > canvasW - ballR) { curDX *= -1; collided = true; }
        if (nextY < ballR) { curDY *= -1; collided = true; }
        for (let r=0; r<bricks.length; r++) {
            for (let c=0; c<bricks[r].length; c++) {
                let b = bricks[r][c];
                if (b.status > 0 && nextX > b.x && nextX < b.x + b.w && nextY > b.y && nextY < b.y + b.h) {
                    if (curX <= b.x || curX >= b.x + b.w) curDX *= -1; else curDY *= -1;
                    collided = true; break;
                }
            }
            if (collided) break;
        }
        ctx.lineTo(nextX, nextY); curX = nextX; curY = nextY;
        if (collided) { reflections++; if (reflections >= 2) break; }
        if (curY > canvasH) break;
    }
    ctx.stroke(); ctx.restore();
}

canvas.addEventListener('touchstart', (e) => {
    let t = e.touches[0];
    if (!ballActive) {
        if (t.clientX > paddleX - 20 && t.clientX < paddleX + paddleW + 20) isDragging = true;
    } else isDragging = true;
});

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (!isDragging) return;
    let t = e.touches[0], tx = t.clientX, ty = t.clientY;
    if (!ballActive) {
        if (ty < canvasH - PADDLE_BOTTOM_OFFSET + 20) { isAiming = false; paddleX = tx - paddleW / 2; }
        else {
            isAiming = true;
            launchAngle = Math.atan2(ballY - ty, ballX - tx);
            if (launchAngle > -0.1) launchAngle = -0.1;
            if (launchAngle < -Math.PI + 0.1) launchAngle = -Math.PI + 0.1;
        }
    } else paddleX = tx - paddleW / 2;
    if (paddleX < 0) paddleX = 0; if (paddleX > canvasW - paddleW) paddleX = canvasW - paddleW;
}, { passive: false });

canvas.addEventListener('touchend', () => {
    if (isDragging && !ballActive && isAiming) {
        ballActive = true;
        ballDX = Math.cos(launchAngle) * 7; ballDY = Math.sin(launchAngle) * 7;
        hintDisp.style.opacity = "0";
    }
    isDragging = false; isAiming = false;
});

function resetBall() { ballActive = false; ballPower = 1; }
function endGame(s) { msgDisp.innerText = s; msgDisp.style.display = "block"; restartBtn.style.display = "block"; ballActive = false; }

function resetFullGame() {
    lives = 5; liveDisp.innerText = lives; 
    paddleW = canvasW / 4; ballPower = 1;
    msgDisp.style.display = "none"; restartBtn.style.display = "none";
    hintDisp.style.opacity = "1";
    items = []; // æ¸…ç©ºæœªæ¥åˆ°çš„é“å…·
    initBricks(); resetBall();
}

initBricks(); resetBall(); draw();
</script>
</body>
</html>